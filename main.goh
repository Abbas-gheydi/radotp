package main

import (
	"log"

	"github.com/Abbas-gheydi/radotp/pkgs/base"

	"layeh.com/radius"
	"layeh.com/radius/rfc2865"
)

func main() {
	//initial state pool
	var ourpool base.Statepool
	ourpool.Init()

	handler := func(w radius.ResponseWriter, r *radius.Request) {
		paket := r.Packet
		username := rfc2865.UserName_GetString(paket)
		password := rfc2865.UserPassword_GetString(paket)
		state := rfc2865.State_GetString(paket)
		var code radius.Code
		// user first must to authenticate with user and password
		if state == "" {

			code = base.CheckUserPass(username, password)
			if code == radius.CodeAccessChallenge {

				base.SendForChalenge(w, r, &ourpool)

				//Wrong user and pass
			} else {

				base.RejectUser(w, r)

			}

			log.Printf("password check %v to %v for %v", code, r.RemoteAddr, username)

			//w.Write(paket)
			// user hast state then must athenticate with otp code
		} else {

			//lookup state
			// state is ok
			if string(rfc2865.State_Get(r.Packet)) == string(ourpool.Lookup(rfc2865.UserName_GetString(r.Packet))) {
				log.Println("state is ok")

				//validate otp code
				code = base.CheckOtpCode(username, password)
				if code == radius.CodeAccessAccept {
					base.AcceptUser(w, r)
					//delete user from statepool
					ourpool.Delete(rfc2865.UserName_GetString(r.Packet))
				} else {

					base.RejectUser(w, r)
				}

			} else {
				base.RejectUser(w, r)
				code = radius.CodeAccessReject
				log.Println("Warning, state mismatch for user", username)
			}

			log.Printf("otp code %v to %v for %v", code, r.RemoteAddr, username)
		}

	}

	server := radius.PacketServer{
		Handler:      radius.HandlerFunc(handler),
		SecretSource: radius.StaticSecretSource([]byte(`secret`)),
	}

	log.Printf("Starting server on :1812")
	if err := server.ListenAndServe(); err != nil {
		log.Fatal(err)
	}
}
